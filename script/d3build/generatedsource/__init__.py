# Copyright 2014 Dietrich Epp.
# This file is part of SGLib.  SGLib is licensed under the terms of the
# 2-clause BSD license.  For more information, see LICENSE.txt.
import os
import io

NOTICE = 'This file automatically generated by the build system'

class GeneratedSource(object):
    __slots__ = []

    @property
    def is_binary(self):
        return False

    @property
    def is_executable(self):
        return False

    @property
    def is_regenerated_always(self):
        return False

    @property
    def is_regenerated_only(self):
        return False

    @property
    def dependencies(self):
        return ()

    @property
    def target(self):
        raise NotImplementedError('must be implemented by subclass')

    def rule(self):
        return 'Regen', None

    def write(self, fp):
        """Write the data to a file."""
        raise NotImplementedError('must be implemented by subclass')

    def makedirs(self):
        dirpath = os.path.dirname(self.target)
        if dirpath:
            os.makedirs(dirpath, exist_ok=True)

    def regen(self):
        """Regenerate the file."""
        if self.is_binary:
            fp = io.BytesIO()
            self.write(fp)
            value = fp.getvalue()
        else:
            fp = io.StringIO()
            self.write(fp)
            value = fp.getvalue().encode('UTF-8')

        if self.is_regenerated_always:
            try:
                with open(self.target, 'rb') as fp:
                    oldvalue = fp.read()
            except FileNotFoundError:
                self.makedirs()
            else:
                if oldvalue == value:
                    return

        try:
            if self.is_executable:
                fdes = os.open(
                    self.target + '.tmp',
                    os.O_WRONLY | os.O_CREAT | os.O_TRUNC,
                    0o777)
                with os.fdopen(fdes, 'wb') as fp:
                    fp.write(value)
            else:
                with open(self.target + '.tmp', 'wb') as fp:
                    fp.write(value)
            os.replace(self.target + '.tmp', self.target)
        except:
            try:
                os.remove(self.target + '.tmp')
            except FileNotFoundError:
                pass
            raise
