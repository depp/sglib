from __future__ import with_statement
import os
import buildtool.source as source
import sys
import shutil
import posixpath
import buildtool.git as git
import re

ACTIONS = ['cmake', 'gmake', 'xcode', 'build']
DEFAULT = {
    'Linux': 'gmake',
    'Darwin': 'xcode',
    'Windows': 'cmake',
}

PROPS = set(['pkg_name', 'pkg_ident', 'pkg_filename', 'exe_name',
             'exe_file_linux', 'exe_file_mac', 'exe_file_windows'])

class ToolInvocation(object):
    def __init__(self, tool):
        self._tool = tool
        self.warning = 'This file automatically generated by buildgen.py'

    def _mkdirp(self, path):
        apath = self._tool._rootpath(path)
        if not path or os.path.isdir(apath):
            return
        self._mkdirp(os.path.dirname(path))
        os.mkdir(apath)

    def write_file(self, path, data):
        """Write a file with the given contents to the given path."""
        self._mkdirp(os.path.dirname(path))
        print path
        abspath = self._tool._rootpath(path)
        try:
            with open(abspath, 'w') as f:
                f.write(data)
        except:
            try:
                os.unlink(abspath)
            except OSError:
                pass
            raise

    def get_atoms(self, *atoms):
        """Get all source files with the given atoms.

        This returns a list of all source files which have at least
        one of the atoms listed.  If None appears in the list, then
        source files with no atoms will also be included.
        """
        result = []
        for src in self._tool._sources:
            for atom in atoms:
                if atom is None:
                    if not src.atoms:
                        result.append(src.path)
                        break;
                else:
                    if atom in src.atoms:
                        result.append(src.path)
                        break
        return result

    def all_sources(self):
        """Get a list of all sources."""
        return [src.path for src in self._tool._sources]

    @property
    def incldirs(self):
        return self._tool._incldirs

    def _writeversion(self):
        vers = git.describe('.')
        self.write_file(
            'version.c',
            'const char SG_VERSION[] = "%s";\n' % vers)

    def __getattr__(self, name):
        if name in PROPS:
            return getattr(self._tool, name)
        else:
            raise AttributeError(name)

class UnsetProperty(Exception):
    def __init__(self, prop, fallback=()):
        self.prop = prop
        self.fallback = fallback
    def __repr__(self):
        if self.fallback:
            return 'UnsetProperty(%r)' % self.prop
        else:
            return 'UnsetProperty(%r, %r)' % (self.prop, self.fallback)
    def __str__(self):
        if self.fallback:
            return 'property not set: %s (defaults from %s)' % \
                (self.prop, ', '.join(self.fallback))
        else:
            return 'property not set: %s' % self.prop

class InvalidProperty(ValueError):
    def __init__(self, prop, value):
        self.prop = prop
        self.value = value
    def __repr__(self):
        return 'InvalidProperty(%r, %r)' % (self.prop, self.value)
    def __str__(self):
        return 'invalid value for %s property: %r' % \
            (self.prop, self.value)

class Property(object):
    def __init__(self, name, check, default=None):
        self.name = name
        self.check = check
        self.default = default

    def __get__(self, instance, owner):
        try:
            return instance._props[self.name]
        except KeyError:
            if self.default is not None:
                try:
                    return self.default(instance)
                except UnsetProperty, ex:
                    raise UnsetProperty(self.name, (ex.prop,) + ex.fallback)
            raise UnsetProperty(self.name)

    def __set__(self, instance, value):
        if isinstance(self.check, str):
            match = re.match(self.check, value)
        else:
            match = self.check(value)
        if not match:
            raise InvalidProperty(self.name, value)
        else:
            instance._props[self.name] = value

    def __delete__(self, instance):
        del instance._props[self.name]


_title = r'^[-\w]+(?: [-\w]+)*$'
_file = r'\w+'
_domain = (r'^[a-z0-9](?:[-a-z0-9]*[a-z0-9])?' 
           r'(?:\.[a-z0-9](?:[-a-z0-9]*[a-z0-9])?)*$')
def _tofile(x):
    return re.sub('[-_ ]+', '_', x)

class Tool(object):
    def __init__(self):
        self._rootdir = None
        self._atoms = set()
        self._sources = []
        self._incldirs = []
        self._props = {}

    def rootdir(self, path):
        """Set the root directory."""
        if self._rootdir is not None:
            raise Exception('Already have a root directory')
        os.chdir(path)
        self._rootdir = True

    def _rootpath(self, path):
        """Get a rootdir-relative path."""
        if not self._rootdir:
            raise Exception('Need a root directory')
        return path

    def srclist(self, path, *atoms):
        """Add a list of source files from a list at the given path.

        The file is relative to the source directory, and paths in the
        file are relative to the file's directory.
        """
        if os.path.sep != '/':
            base = path.replace(os.path.sep, '/')
        else:
            base = path
        base = posixpath.dirname(base)
        for line in open(self._rootpath(path), 'r'):
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            line = line.split()
            fpath, fatoms = line[0], line[1:]
            fatoms.extend(atoms)
            fpath = posixpath.join(base, fpath)
            self._atoms.update(fatoms)
            self._sources.append(source.Source(fpath, fatoms))

    def includepath(self, *paths):
        """Search the given directories for header files."""
        for path in paths:
            if not os.path.isdir(path):
                print >>sys.stderr, 'Warning: not a directory: %r' % path
        self._incldirs.extend(paths)

    def _run(self, opts, args):
        actions = []
        if not args:
            import platform
            s = platform.system()
            try:
                args = DEFAULT[s]
            except KeyError:
                print >>sys.stderr, 'Error: no action specified\n' \
                    'No default action for %s platform' % s
                sys.exit(1)
            if isinstance(args, str):
                args = (args,)
        for arg in args:
            if arg not in ACTIONS:
                print >>sys.stderr, 'Error: unknown backend %r' % arg
                sys.exit(1)
            actions.append(arg)
        self._sources.append(source.Source('version.c', []))
        i = ToolInvocation(self)
        i._writeversion()
        for b in actions:
            m = getattr(__import__('buildtool.' + b), b)
            m.run(i)

    def run(self):
        import optparse
        p = optparse.OptionParser()
        opts, args = p.parse_args()
        self._run(opts, args)

    pkg_name = Property('pkg_name', _title)
    pkg_ident = Property('pkg_ident', _domain)
    pkg_filename = Property('pkg_filename', _file,
                            lambda x: _tofile(x.pkg_name))

    exe_name = Property('exe_name', _title, lambda x: x.pkg_name)
    exe_file_linux = Property('exe_file_linux', _file,
                              lambda x: _tofile(x.exe_name))
    exe_file_mac = Property('exe_file_mac', _title,
                            lambda x: x.exe_name)
    exe_file_windows = Property('exe_file_windows', _title,
                                lambda x: x.exe_name)

