from __future__ import with_statement

from cStringIO import StringIO
from gen.env.nix import default_env, getmachine
from gen.shell import escape
from gen.path import Path
import re
import os

def mkcvar(c):
    k, v = c
    a = []
    for x in v:
        if isinstance(x, Path):
            x = x.posix
        a.append(x)
    return '-d%s=%s' % (k, ''.join(a))

def subst(text, d):
    def func(m):
        return d[m.group(1)]
    return re.sub(r'@(\w+)@', func, text)

def gen_runner(config):
    bcfg = config.get_config('LINUX')
    base = default_env(config, 'LINUX')
    machine = getmachine(base)

    targets = set()
    variants = set()
    run_dispatch = StringIO()
    for target in bcfg.targets:
        app_name = target.target.exe_name['LINUX']
        targets.add(app_name)
        variant = target.variant.varname.lower()
        variants.add(variant)
        exe_name = '%s_%s_%s' % (app_name, machine, variant)
        d = {
            'APP': escape(app_name),
            'VARIANT': escape(variant),
            'PATH': escape('build/product/' + exe_name),
            'ARGS': ' '.join(escape(mkcvar(x)) for x in target.cvars),
        }
        run_dispatch.write(subst(RUN_CASE, d))

    variants = list(variants)
    variants.sort()
    targets = list(targets)
    targets.sort()
    arg_dispatch = StringIO()
    variant_list = StringIO()
    app_list = StringIO()
    for variant in variants:
        d = {'VARIANT': escape(variant)}
        arg_dispatch.write(subst(VARIANT_CASE, d))
        variant_list.write('  %s\n' % variant)
    for app in targets:
        d = {'APP': escape(app)}
        arg_dispatch.write(subst(APP_CASE, d))
        app_list.write('  %s\n' % app)

    d = {
        'TARGETS': app_list.getvalue(),
        'VARIANTS': variant_list.getvalue(),
    }
    helptext = subst(HELP, d)

    d = {
        'DEFAULT_APP': escape(targets[0]),
        'DEFAULT_VARIANT': escape(variants[0]),
        'HELP': helptext,
        'ARG_DISPATCH': arg_dispatch.getvalue(),
        'RUN_DISPATCH': run_dispatch.getvalue(),
    }
        
    script = subst(SHELL_SCRIPT, d)


    fd = os.open('run.sh', os.O_WRONLY | os.O_CREAT | os.O_TRUNC, 0o777)
    fp = os.fdopen(fd, 'wb')
    fp.write(script)
    fp.close()

SHELL_SCRIPT = """\
#!/bin/sh
# This file automatically generated by build system
set -e

MODE=normal
APP=@DEFAULT_APP@
VARIANT=@DEFAULT_VARIANT@

for i; do
    case "$i" in
        --gdb)
            MODE=gdb
            shift
            ;;
        --valgrind)
            MODE=valgrind
            shift
            ;;
        --help)
            cat >&2 <<EOF
@HELP@\
EOF
            exit 1;
            ;;
@ARG_DISPATCH@\
        *)
            break
            ;;
    esac
done

unbuilt()
{
    cat <<EOF
error: $1 does not exist
Did you forget to run 'make'?
EOF
    exit 1
}

case "$APP:$VARIANT:$MODE" in
@RUN_DISPATCH@\
    *)
        echo 'error: unknown application / variant' >&2
        exit 1
        ;;
esac
"""

HELP = """\
Usage: run.sh [options..] [target] [variant] [target-options..]

Run the given target.

Targets:
@TARGETS@\

Variants:
@VARIANTS@\

Options:
  --gdb         run the target in GDB
  --help        show this help screen
  --valgrind    run the target through Valgrind
"""

APP_CASE = """\
        @APP@)
            APP=@APP@
            ;;
"""

VARIANT_CASE = """\
        @VARIANT@)
            VARIANT=@VARIANT@
            ;;
"""

RUN_CASE = """\
    @APP@:@VARIANT@:normal)
        test -x @PATH@ || unbuilt @PATH@
        exec @PATH@ @ARGS@ "$@"
        ;;
    @APP@:@VARIANT@:gdb)
        test -x @PATH@ || unbuilt @PATH@
        exec gdb --args @PATH@ @ARGS@ "$@"
        ;;
    @APP@:@VARIANT@:valgrind)
        test -x @PATH@ || unbuilt @PATH@
        exec valgrind -- @PATH@ @ARGS@ "$@"
        ;;
"""
